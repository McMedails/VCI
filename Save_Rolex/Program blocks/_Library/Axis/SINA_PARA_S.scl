FUNCTION_BLOCK "SINA_PARA_S"
TITLE = 'one parameter exchange between SINAMICS and S7'
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : DRVDPS7
FAMILY : DRIVES
NAME : SINA_PAS
VERSION : 5.1
//Copyright (C) Siemens AG 2012. All Rights Reserved. Confidential
//--------------------------------------------------------------------------- 
//SINA_PARA_S: Austausch eines beliebigen Parameter zwischen SINAMICS S120/G120 <-> S7
//-------------------------------------------------------------------------- Ersteller: J.B. Typical Team               Datum:  25.06.14        Vers.:3.0
//    Übernahme vom SINA_PARA Verion 2.9 und Abänderung zu SINA_PARA_S
//    Austausch nur noch eines Parameters
//
//Änderung:  J.B. Typical Team                       08.07.14              3.1
//    Fehlerkorrektur und Initialisierung 
//    Änderung
//Änderung:  J.B. Typical Team                       30.07.14              4.0
//    Festlegung auf einheitlicher neuer Version 4.0
//
//Änderung:  G.F. Typical Team                       20.05.15              4.1
//    Fehler bei der Umrechnung der Parameterwerte behoben
//
//Änderung:  G.F. Typical Team                       15.09.15              4.2
//    Defaultwert des Parameters AxisNo von 0 auf 1 geändert
//
//Änderung:  G.F. Typical Team                       06.10.15              4.3
//    Defaultwert des Parameters Done von 0 auf 1 geändert
//
//Änderung:  J.B. Typical Team                       08.12.15              4.4
//    1. Wenn beim Parameter "Lesen" ein Fehler zurück gemeldet wird, 
//    soll das "Schreiben" abgebrochen werden
//
//    2. Für den Datentyp DWORD mit/ohne Vorzeichen neuer Ablageort
//    (statt REAL nun DINT)
//
//    3. Neue Ausgangsvariable Ready = Lesen/Schreiben der Parameter
//    abgeschlossen
//
//    4. Austauch der Parameter kann jetzt abgebrochen werden
//
//    5. Warnung durch Initialisierung elimininiert
//
//    6. Eingang Laddr in hardwareId umbenannt
//
//Änderung:  G.F. Typical Team                       24.11.16              4.5
//    - Fehlerausgabe bei unbekannten Datentyp (ErrorId := 5)
//    - Datentyp 10 (OctetString) wird unterstützt
//    - Datentyp 13 (TimeDifference) wird unterstützt
//    - Fehler bei Auftrag abbrechen behoben
//
//Änderung:  G.F. Typical Team                       11.01.17              5.0
//    - Festlegung auf einheitlicher neuer Version 5.0 
//
//Bibliothek V7
//Funktion: Austausch eines beliebigen Parameter zwischen SINAMICS S120/G120 <-> S7
//********************************************************************************************************************************************************
//************************************************************************FB283***************************************************************************
//********************************************************************************************************************************************************
   VAR_INPUT 
      Start { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Bool := 0;   // Start command for read or write parameter
      ReadWrite { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Bool := 0;   // Type of job 0 = read parameter, 1 = write parameter
      Parameter { CFC_Visible := 'true'; CFC_ForTest := 'true'} : UInt := 1;   // Number of parameter (number 1..65535)
      Index { CFC_Visible := 'true'; CFC_ForTest := 'true'} : UInt := 0;   // Subindex (number 0..65535)
      ValueWrite1 { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Real := 0.0;   // Value of the write parameter (byte, word, float)
      ValueWrite2 { CFC_Visible := 'true'; CFC_ForTest := 'true'} : DInt := 0;   // Value of the write parameter (dint)
      AxisNo { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Byte := 16#01;   // Object ID of drive
      hardwareId : HW_IO := 0;   // Configured diagnosis address of the module (DEC) for WRREC and RDREC Output variables
   END_VAR

   VAR_OUTPUT 
      Ready { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Bool := 0;   // Read or write parameter order ready
      Busy { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Bool := 0;   // Mode of operation is explained
      Done { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Bool := 1;   // Mode of operation without mistake finishes
      ValueRead1 { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Real := 0.0;   // Value of the read parameter (byte, word, float)
      ValueRead2 { CFC_Visible := 'true'; CFC_ForTest := 'true'} : DInt := 0;   // Value of the read parameter (dint)
      Format { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Byte := 16#00;   // Format of the value (Format 0x40..0x44)
      ErrorNo { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Word := 16#0000;   // Error number (see table below)
      Error { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Bool := 0;   // Error or faults are active
      ErrorId { CFC_Visible := 'true'; CFC_ForTest := 'true'} : DWord := 0;   // Mode of operation disturbance
      DiagId { CFC_Visible := 'true'; CFC_ForTest := 'true'} : Word := 16#0000;   // Extended communication error Static variables
   END_VAR

   VAR 
      sbWrError : Bool := 0;   // Error when writing with SFB WRREC
      sbWrDone : Bool := 0;   // Data record written with SFB WRREC
      sbRdError : Bool := 0;   // Error when reading with SFB RDREC
      sbWrBusy : Bool := 0;   // Write Task busy SFB 53 WRREC sind beschäftigt
      sbRdBusy : Bool := 0;   // Read Task busy SFB 52 RDREC sind beschäftigt
      sbWrStart : Bool := 0;   // Start write job
      sbRdStart : Bool := 0;   // Start read job
      sbWrStart1 : Bool := 0;   // Start write job (first part of write commando)
      sbRdStart1 : Bool := 0;   // Start read job (first part of read commando)
      sbWrStart2 : Bool := 0;   // Start write job (second part of write commando)
      sbRdStart2 : Bool := 0;   // Start read job (second part of read commando)
      sbStart : Bool := 0;   // Positive edge of Start commando
      sbReady : Bool := 0;   // Positive edge of Ready
      sbRead : Bool := 0;   // Commando "Read"
      sbWrite : Bool := 0;   // Commando "Write"
      sbParaNo : Bool := 0;   // The count of parameter are Okay
      sbBusy : Bool := 0;   // Mode of operation is explained
      sbError : Bool := 0;   // Error or faults are active
      sbDone : Bool := 0;   // Job finished
      syFormat : Byte := 16#00;   // Format of the value (Format 0x40..0x44)
      syAxisNo : Byte := 0;   // Antriebsobjekt ID
      siReqRef : Int := 0;   // Reference number of request
      siErrorId : Int := 0;   // Function block fault Id
      siErrorCount : Int := 0;   // temporary error counter of retry job
      siMaxErrCount : Int := 12500;   // max. temporary error counter
      swParaError : Word := WORD#16#0000;   // Error of parameter
      sxReqParaMulti : Struct   // Telegramm for request/change parameter value, multi-parameter
         sxHeader : Struct   // Request header
            syReqRef : Byte := 16#00;   // Request reference (Request ID, mirrored in response)
            syReqId : Byte := 16#01;   // Request ID 0x1=Read
            syAxisNo : Byte := 16#00;   // Axis (0x0=Axis A | 0x1=Axis B)
            syParaNo : Byte := 16#00;   // No. of parameters (DEC: for single parameters=1)
         END_STRUCT;
         sxParaAdress : Struct   // Parameter address
            syAttr : Byte := 16#10;   // Attribute of parameters (0x10=Value, 0x30=Text)
            syElemNo : Byte := 16#01;   // No. of elements (DEC: for single elements=1)
            siParaNo : UInt := 0;   // Number of parameter (Number 1..65535)
            siIndex : UInt := 0;   // Subindex (Number 1..65535)
         END_STRUCT;
      END_STRUCT;
      sxChaParaMulti : Struct   // Telegramm for change parameter value, multi-parameter
         sxHeader : Struct   // Request header
            syReqRef : Byte := 16#00;   // Request reference (Request ID, mirrored in response)
            syReqId : Byte := 16#02;   // Request ID 0x2=Write
            syAxisNo : Byte := 16#00;   // Axis (0x0=Axis A | 0x1=Axis B)
            syParaNo : Byte := 16#00;   // No. of parameters (DEC: for single parameters=1)
         END_STRUCT;
         sxData : Array[1..12] of Byte;   // Parameter address (Attribute/Value (BYTE), Number of Elements (BYTE), Parameter number (2 BYTES), Subindex (2 BYTES),Parameter value (Format/Error (BYTE), Number of Values/Value of Error (BYTE), Value (BYTE or WORD or DWORD)
      END_STRUCT;
      sxRespParaMulti : Struct   // Telegramm for response parameter value, multi-parameter
         sxHeader : Struct   // Request header
            syReqRef : Byte := 16#00;   // Request reference (Request ID, mirrored in response)
            syReqId : Byte := 16#00;   // Request ID (0x1=Read | 0x2=Write)
            syAxisNo : Byte := 16#00;   // Axis (0x0=Axis A | 0x1=Axis B)
            syParaNo : Byte := 16#00;   // No. of parameters (DEC: for single parameters=1)
         END_STRUCT;
         sxData : Array[1..6] of Byte;   // Parameter value (Format/Error (BYTE), Number of Values/Value of Error (BYTE), Value (BYTE or WORD or DWORD)
      END_STRUCT;
      RDREC_1 {InstructionName := 'RDREC'; LibVersion := '1.0'} : RDREC;
      WRREC_1 {InstructionName := 'WRREC'; LibVersion := '1.1'} : WRREC;
      siLenHeader : Int := 4;   // Length of telegram of header
      siLenParaMulti : Int := 6;   // Length of telegram of data for request and response
      siLenChaPara : Int := 12;   // Length of telegram of data for change parameter Temporary variables
   END_VAR

   VAR_TEMP 
      piCount : Int;   // Freely available counter variable
      piPointer : Int;   // Freely available pointer array variable
      piLenTele : Int;   // Length of telegram of buffer
      piRetSFC : Int;   // Status for fault analysis
      pwWordHigh : Word;   // Help variable of word
      pwWordLow : Word;   // Help variable of word
      pwWord1 : Word;   // Help variable of word
      pwWord2 : Word;   // Help variable of word
      pdDWordHigh : DWord;   // Help variable of dword
      pdDWordLow : DWord;   // Help variable of dword
      pdStatus : DWord;   // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
      pbValidSFB : Bool;   // Status SFB
      piLenSFB : UInt;   // Status length for SFB call
      pwErrorNo : Word;   // Error number
   END_VAR


BEGIN
	
	//=============================================================================
	//SIEMENS AG
	//(c)Copyright 2017 All Rights Reserved
	//-----------------------------------------------------------------------------
	// Library: DriveLib
	// Tested with: S7-1516-3 PN/DP V1.8
	// Engineering: TIA Portal V14
	// Restrictions: -
	// Requirements: S7-1200 / S7-1500
	// Functionality: read and write one parameter from/to a Sinamics
	//
	//=============================================================================
	
	// Auftrag "Parameter lesen" bzw. Auftrag "Parameter schreiben" wird nicht mehr ausgeführt
	IF NOT #sbBusy THEN
	  #sbParaNo := TRUE;
	  #syAxisNo := #AxisNo;
	END_IF;
	
	// Starten 
	IF #Start AND NOT #sbStart AND NOT #sbBusy THEN
	  
	  #sbReady := False;
	  #sbError := False;
	  #sbBusy := False;
	  
	  // Auftrag "Parameter lesen" erkennen
	  IF NOT #ReadWrite THEN
	    #sbRead := True;
	    #sbWrStart := True;
	    #sbRdStart := False;
	    
	    #sbWrite := False;
	    #sbWrStart1 := False;
	    #sbRdStart1 := False;
	    #sbWrStart2 := False;
	    #sbRdStart2 := False;
	    
	    // Referenzauftragsnummer erzeugen
	    #siReqRef := #siReqRef + 1;
	    
	    // bei Überschreitung wieder zurücksetzen und von vorne (Wertebereich von 0-255)
	    IF #siReqRef > 255 THEN
	      #siReqRef := 0;
	    END_IF;
	    
	    // Auftrag "Parameter schreiben" erkennen
	  ELSE
	    #sbWrite := True;
	    #sbWrStart1 := True;
	    #sbRdStart1 := False;
	    #sbWrStart2 := False;
	    #sbRdStart2 := False;
	    
	    #sbRead := False;
	    #sbWrStart := False;
	    #sbRdStart := False;
	    
	    // Referenzauftragsnummer erzeugen
	    #siReqRef := #siReqRef + 1;
	    
	    // bei Überschreitung wieder zurücksetzen und von vorne (Wertebereich von 0-255)
	    IF #siReqRef > 255 THEN
	      #siReqRef := 0;
	    END_IF;
	  END_IF;
	  
	  // Fehler 4 und 5 wieder zurücknehmen
	  IF (#siErrorId = 4) OR (#siErrorId = 5) THEN
	    #sbError := False;
	    #siErrorId := 0;
	  END_IF;
	END_IF;
	
	// "Start commando" Flanke merken
	#sbStart := #Start;
	
	// Abbrechen
	IF NOT #Start THEN
	  
	  #siErrorCount := 0;
	  // Schreib - oder Lesevorgang abbrechen
	  #sbRead := False;
	  #sbWrStart := False;
	  #sbRdStart := False;
	  
	  #sbWrite := False;
	  #sbWrStart1 := False;
	  #sbRdStart1 := False;
	  #sbWrStart2 := False;
	  #sbRdStart2 := False;
	  
	  // Auftag ist noch beschäftigt => Fehler ausgeben
	  IF #sbBusy THEN
	    #sbError := True;
	    #siErrorId := 4;
	    #sbBusy := False;
	  END_IF;
	END_IF;
	
	
	// Auftrag "Parameter lesen" wurde ausgelöst
	IF #sbParaNo AND #sbRead AND NOT #sbWrite THEN
	  
	  // Auftrag "Parameter lesen" vorbereiten und abschicken
	  IF #sbWrStart THEN
	    
	    // Ablöschen des Sendepuffers
	    // Parameternummer des Parameters 
	    #sxReqParaMulti.sxParaAdress.siParaNo := 0;
	    
	    // Subindex des Parameters
	    #sxReqParaMulti.sxParaAdress.siIndex := 0;
	    
	    // Auftrags-HEADER erstellen
	    // Auftragsreferenz
	    #sxReqParaMulti.sxHeader.syReqRef := INT_TO_BYTE(#siReqRef);
	    
	    // Auftragskennung 0x01=Request Parameters
	    #sxReqParaMulti.sxHeader.syReqId := B#16#01;
	    
	    // Achse
	    #sxReqParaMulti.sxHeader.syAxisNo := #syAxisNo;
	    
	    // Anzahl Parameter        
	    #sxReqParaMulti.sxHeader.syParaNo := B#16#01;
	    
	    // Auftrags-PARAMETERADRESSE erstellen
	    // Parameternummer des Parameters                                
	    #sxReqParaMulti.sxParaAdress.siParaNo := #Parameter;
	    
	    // Subindex des Parameters
	    #sxReqParaMulti.sxParaAdress.siIndex := #Index;
	    
	    // SCHREIBEN AZYKLISCH
	    #piLenTele := #siLenHeader + #siLenParaMulti;
	    #WRREC_1(REQ := True,                                // Startimpuls
	             ID := #hardwareId,                         // Diagnoseadresse
	             INDEX := 47,                                  // Rahmentyp
	             LEN := INT_TO_UINT(#piLenTele),             // maximale Länge
	             DONE => #sbWrDone,                           // Schreibauftrag beendet
	             BUSY => #sbWrBusy,                           // Slave beschäftigt
	             ERROR => #sbWrError,                          // Fehler beim Schreiben
	             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
	             RECORD := #sxReqParaMulti);                    // Zeiger auf zu schreibenen Datensatzes
	    
	    // Ausgänge setzen
	    #sbBusy := #sbWrBusy;
	    #sbDone := #sbWrDone;
	    
	    // Fehler auswerten
	    IF #sbWrError THEN
	      
	      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
	      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
	      
	      // Fehlerstatus setzen
	      #siErrorId := 3;
	      #DiagId := #pwWord1;
	      
	      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
	      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
	        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
	        NOT (#pwWord1 = DW#16#80C4) THEN
	        
	        // Wiederholungsauftrag wieder zurücknehmen 
	        #sbWrStart := False;
	        #sbRdStart := False;
	        #sbRead := False;
	        
	        // Fehler ausgeben 
	        #sbError := #sbWrError;
	        
	      ELSE
	        // Fehlerwiederholauftrag ??                   
	        IF #siErrorCount = #siMaxErrCount THEN
	          
	          // Wiederholungsauftrag wieder zurücknehmen
	          #sbWrStart := False;
	          #sbRdStart := False;
	          #sbRead := False;
	          
	          //Fehlerzähler zurücksetzen
	          #siErrorCount := 0;
	          
	          
	          // Fehler ausgeben 
	          #sbError := #sbWrError;
	          
	          // nix tun bis Zähler überläuft
	        ELSE
	          #siErrorCount := #siErrorCount + 1;
	        END_IF;
	      END_IF;
	      
	      // kein Fehler beim SCHEIBEN AZYKLISCH und Auftrag fertig 
	    ELSIF NOT #sbWrBusy AND #sbWrDone THEN
	      
	      // Fehlerkennung zurücknehmen
	      IF #siErrorId = 3 THEN
	        #siErrorId := 0;
	        #sbError := False;
	      END_IF;
	      
	      #DiagId := W#16#00;
	      
	      // Schreibauftrag fertig melden und Leseantrag anstossen
	      #sbWrStart := False;
	      #sbRdStart := True;
	    END_IF;
	  END_IF; // Auftrag "Parameter lesen" vorbereiten und abschicken
	  
	  // vom Auftrag "Parameter lesen" die Antwort abwarten und dann auswerten
	  IF #sbRdStart THEN
	    
	    // Ablöschen des Empfangspuffers
	    #sxRespParaMulti.sxHeader.syReqRef := B#16#00;
	    #sxRespParaMulti.sxHeader.syReqId := B#16#00;
	    #sxRespParaMulti.sxHeader.syAxisNo := B#16#00;
	    #sxRespParaMulti.sxHeader.syParaNo := B#16#00;
	    
	    FOR #piCount := 1 TO #siLenParaMulti DO
	      #sxRespParaMulti.sxData[#piCount] := B#16#00;
	    END_FOR;
	    
	    // LESEN AZYKLISCH
	    #piLenTele := #siLenHeader + #siLenParaMulti;
	    #RDREC_1(REQ := True,                                // Startimpuls
	             ID := #hardwareId,                         // Diagnoseadresse        
	             INDEX := 47,                                  // Rahmentyp           
	             MLEN := INT_TO_UINT(#piLenTele),             // maximale Länge
	             VALID => #pbValidSFB,                         // neuer Datensatz empfangen und gültig   
	             BUSY => #sbRdBusy,                           // Slave beschäftigt
	             ERROR => #sbRdError,                          // Fehler beim Schreiben
	             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code 
	             LEN => #piLenSFB,                           // Länge des gelesenen Datensatzes
	             RECORD := #sxRespParaMulti);                   // Zeiger auf gelesenen Datensatz
	    
	    // Ausgänge setzen
	    #sbBusy := #sbRdBusy;
	    #sbDone := #pbValidSFB;
	    
	    // Fehler auswerten
	    IF #sbRdError THEN
	      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
	      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
	      
	      // Fehlerstatus setzen
	      #siErrorId := 3;
	      #DiagId := #pwWord1;
	      
	      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
	      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
	        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
	        NOT (#pwWord1 = DW#16#80C4) THEN
	        
	        // Wiederholungsauftrag wieder zurücknehmen  
	        #sbWrStart := False;
	        #sbRdStart := False;
	        #sbRead := False;
	        
	        // Fehler ausgeben 
	        #sbError := #sbRdError;
	        
	      ELSE
	        // Fehlerwiederholauftrag ??                   
	        IF #siErrorCount = #siMaxErrCount THEN
	          
	          // Wiederholungsauftrag wieder zurücknehmen
	          #sbWrStart := False;
	          #sbRdStart := False;
	          #sbRead := False;
	          
	          //Fehlerzähler zurücksetzen
	          #siErrorCount := 0;
	          
	          
	          // Fehler ausgeben 
	          #sbError := #sbRdError;
	          
	          // nix tun bis Zähler überläuft
	        ELSE
	          #siErrorCount := #siErrorCount + 1;
	        END_IF;
	      END_IF;
	      
	      // Fehler : die Auftragsreferenz der Antwort übertimmt nicht mit der Auftragsreferenz der Anfrage überein
	    ELSIF NOT (#siReqRef = BYTE_TO_INT(#sxRespParaMulti.sxHeader.syReqRef)) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen  
	      #sbWrStart := False;
	      #sbRdStart := False;
	      #sbRead := False;
	      
	      // Fehler : falsche Auftragskennung zurück erhalten    
	    ELSIF NOT (#sxRespParaMulti.sxHeader.syReqId = B#16#81 OR #sxRespParaMulti.sxHeader.syReqId = B#16#01) AND
	      NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen  
	      #sbWrStart := False;
	      #sbRdStart := False;
	      #sbRead := False;
	      
	      // Fehler : die angeforderte Anzahl Parameter entspricht nicht der übermittelten Anzahl Parameter überein
	    ELSIF NOT (#sxRespParaMulti.sxHeader.syParaNo = B#16#01) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen  
	      #sbWrStart := False;
	      #sbRdStart := False;
	      #sbRead := False;
	      
	      // Fehler : die Achse entspricht nicht der übergebenen Achse
	    ELSIF NOT (#syAxisNo = #sxRespParaMulti.sxHeader.syAxisNo) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen  
	      #sbWrStart := False;
	      #sbRdStart := False;
	      #sbRead := False;
	      
	      // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
	    ELSIF NOT #sbRdBusy AND #pbValidSFB THEN
	      
	      // die angefragten Parameter auswerten und im Puffer abspeichern
	      
	      // ermitteltes Format des Parameters abspeichern
	      #syFormat := #sxRespParaMulti.sxData[1];
	      
	      // Format = Error ? = > gesendeter Parameter fehlerhaft
	      IF (BYTE_TO_INT(#sxRespParaMulti.sxData[1]) = 68) THEN
	        
	        // Format = Error, zwei Bytes zu übermittelten Fehlernummer zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	        
	        #sbError := True;
	        
	        // ermittelte Fehlernummer im Puffer abspeichern
	        #ErrorNo := #pwWordHigh XOR #pwWordLow;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
	        #swParaError := #swParaError OR W#16#01;
	        
	        // Format = Byte ? = > gesendeter Parameter ein Byte lang ohne Vorzeichen
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#41) OR (#sxRespParaMulti.sxData[1] = B#16#05) THEN
	        
	        // ermittelter Parameterwert eintragen (Byte) 
	        #ValueRead1 := USINT_TO_REAL(BYTE_TO_USINT(#sxRespParaMulti.sxData[3]));
	        #ValueRead2 := 0;
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Byte ? = > gesendeter Parameter ein Byte lang mit Vorzeichen
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#02) THEN
	        
	        // ermittelter Parameterwert eintragen (Byte) 
	        #ValueRead1 := SINT_TO_REAL(BYTE_TO_SINT(#sxRespParaMulti.sxData[3]));
	        #ValueRead2 := 0;
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Word ? = > gesendeter Parameter zwei Bytes lang ohne Vorzeichen
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#42) OR (#sxRespParaMulti.sxData[1] = B#16#06)
	        OR (#sxRespParaMulti.sxData[1] = B#16#0A) THEN
	        
	        // Format = Word, zwei Bytes zu übermitteltem Parameterwert zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	        #pwWord1 := #pwWordHigh XOR #pwWordLow;
	        
	        // ermittelter Parameterwert eintragen (Word)
	        #ValueRead1 := UINT_TO_REAL(WORD_TO_UINT(#pwWord1));
	        #ValueRead2 := 0;
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Word ? = > gesendeter Parameter zwei Bytes lang mit Vorzeichen
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#03) THEN
	        
	        // Format = Word, zwei Bytes zu übermitteltem Parameterwert zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	        #pwWord1 := #pwWordHigh XOR #pwWordLow;
	        
	        // ermittelter Parameterwert eintragen (Word)
	        #ValueRead1 := INT_TO_REAL(WORD_TO_INT(#pwWord1));
	        #ValueRead2 := 0;
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang ohne Vorzeichen
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#43) OR (#sxRespParaMulti.sxData[1] = B#16#07) OR
	        (#sxRespParaMulti.sxData[1] = B#16#0D) THEN
	        
	        // Format = Double Word, vier Bytes zu übermitteltem Parameterwert zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	        #pwWord1 := #pwWordHigh XOR #pwWordLow;
	        
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[5]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[6]);
	        #pwWord2 := #pwWordHigh XOR #pwWordLow;
	        
	        #pdDWordHigh := SHL(IN := WORD_TO_DWORD(#pwWord1), N := 16);
	        #pdDWordLow := WORD_TO_DWORD(#pwWord2);
	        
	        // ermittelter Parameterwert eintragen (Word)
	        #ValueRead1 := 0.0;
	        #ValueRead2 := DWORD_TO_DINT(#pdDWordHigh XOR #pdDWordLow);
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang mit Vorzeichen
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#04) THEN
	        
	        // Format = Double Word, vier Bytes zu übermitteltem Parameterwert zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	        #pwWord1 := #pwWordHigh XOR #pwWordLow;
	        
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[5]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[6]);
	        #pwWord2 := #pwWordHigh XOR #pwWordLow;
	        
	        #pdDWordHigh := SHL(IN := WORD_TO_DWORD(#pwWord1), N := 16);
	        #pdDWordLow := WORD_TO_DWORD(#pwWord2);
	        
	        // ermittelter Parameterwert eintragen (Word)
	        #ValueRead1 := 0.0;
	        #ValueRead2 := DWORD_TO_DINT(#pdDWordHigh XOR #pdDWordLow);
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang (FloatingPoint)
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#08) THEN
	        
	        // Format = Double Word, vier Bytes zu übermitteltem Parameterwert zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	        #pwWord1 := #pwWordHigh XOR #pwWordLow;
	        
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[5]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[6]);
	        #pwWord2 := #pwWordHigh XOR #pwWordLow;
	        
	        #pdDWordHigh := SHL(IN := WORD_TO_DWORD(#pwWord1), N := 16);
	        #pdDWordLow := WORD_TO_DWORD(#pwWord2);
	        
	        // ermittelter Parameterwert eintragen (Word)
	        #ValueRead1 := DWORD_TO_REAL(#pdDWordHigh XOR #pdDWordLow);
	        #ValueRead2 := 0;
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Unbekanter Datentyp
	      ELSE
	        
	        #siErrorId := 5;
	        #sbError := True;
	        #sbDone := False;
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
	        #swParaError := #swParaError OR W#16#01;
	        
	      END_IF;
	      
	      // Fehlerkennung zurücknehmen
	      IF (#siErrorId = 3) OR (#siErrorId = 1) THEN
	        #siErrorId := 0;
	        #sbError := False;
	      END_IF;
	      
	      #DiagId := W#16#00;
	      
	      // Auftrag : Parameter lesen ist abgeschlossen
	      #sbRdStart := False;
	      #sbRead := False;
	    END_IF; // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
	  END_IF; // vom Auftrag "Parameter lesen" die Antwort abwarten und dann auswerten 
	END_IF; // Auftrag "Parameter lesen" wurde ausgelöst
	
	// Auftrag "Parameter schreiben" wurde ausgelöst
	IF #sbParaNo AND NOT #sbRead AND #sbWrite THEN
	  
	  // Auftrag "Parameter schreiben" bzw. "ändern" besteht aus zwei Aufträgen
	  // 1. Teilauftrag "Parameter lesen"
	  // 2. Teilauftrag "Parameter schreiben bzw. ändern"
	  
	  // 1. Teilauftrag "Parameter lesen" vorbereiten und abschicken
	  IF #sbWrStart1 THEN
	    
	    // Ablöschen des Sendepuffers
	    // Parameternummer des Parameters 
	    #sxReqParaMulti.sxParaAdress.siParaNo := 0;
	    
	    // Subindex des Parameters
	    #sxReqParaMulti.sxParaAdress.siIndex := 0;
	    
	    // Auftrags-HEADER erstellen
	    // Auftragsreferenz
	    #sxReqParaMulti.sxHeader.syReqRef := INT_TO_BYTE(#siReqRef);
	    
	    // Auftragskennung 0x01=Request Parameters
	    #sxReqParaMulti.sxHeader.syReqId := B#16#01;
	    
	    // Achse
	    #sxReqParaMulti.sxHeader.syAxisNo := #syAxisNo;
	    
	    // Anzahl Parameter        
	    #sxReqParaMulti.sxHeader.syParaNo := B#16#01;
	    
	    // Auftrags-PARAMETERADRESSE erstellen
	    // Parameternummer des Parameters                                
	    #sxReqParaMulti.sxParaAdress.siParaNo := #Parameter;
	    
	    // Subindex des Parameters
	    #sxReqParaMulti.sxParaAdress.siIndex := #Index;
	    
	    // SCHREIBEN AZYKLISCH
	    #piLenTele := #siLenHeader + #siLenParaMulti;
	    #WRREC_1(REQ := True,                                // Startimpuls
	             ID := #hardwareId,                         // Diagnoseadresse
	             INDEX := 47,                                  // Rahmentyp
	             LEN := INT_TO_UINT(#piLenTele),             // maximale Länge
	             DONE => #sbWrDone,                           // Schreibauftrag beendet
	             BUSY => #sbWrBusy,                           // Slave beschäftigt
	             ERROR => #sbWrError,                          // Fehler beim Schreiben
	             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
	             RECORD := #sxReqParaMulti);                    // Zeiger auf zu schreibenen Datensatz
	    
	    // Ausgänge setzen
	    #sbBusy := #sbWrBusy;
	    #sbDone := #sbWrDone;
	    
	    // Fehler auswerten
	    IF #sbWrError THEN
	      
	      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
	      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
	      
	      // Fehlerstatus setzen
	      #siErrorId := 3;
	      #DiagId := #pwWord1;
	      
	      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
	      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
	        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
	        NOT (#pwWord1 = DW#16#80C4) THEN
	        
	        // Wiederholungsauftrag wieder zurücknehmen
	        #sbWrStart1 := False;
	        #sbRdStart1 := False;
	        #sbWrite := False;
	        
	        // Fehler ausgeben 
	        #sbError := #sbWrError;
	        
	      ELSE
	        // Fehlerwiederholauftrag ??                   
	        IF #siErrorCount = #siMaxErrCount THEN
	          
	          // Wiederholungsauftrag wieder zurücknehmen
	          #sbWrStart1 := False;
	          #sbRdStart1 := False;
	          #sbWrite := False;
	          
	          //Fehlerzähler zurücksetzen
	          #siErrorCount := 0;
	          
	          
	          // Fehler ausgeben 
	          #sbError := #sbWrError;
	          // nix tun bis Zähler überläuft
	        ELSE
	          #siErrorCount := #siErrorCount + 1;
	        END_IF;
	      END_IF;
	      
	      // kein Fehler beim SCHEIBEN AZYKLISCH und Auftrag fertig 
	    ELSIF NOT #sbWrBusy AND #sbWrDone THEN
	      
	      // Fehlerkennung zurücknehmen
	      IF (#siErrorId = 3) THEN
	        #siErrorId := 0;
	        #sbError := False;
	      END_IF;
	      
	      #DiagId := W#16#00;
	      
	      // Schreibauftrag fertig melden und Leseantrag anstossen
	      #sbWrStart1 := False;
	      #sbRdStart1 := True;
	    END_IF;
	  END_IF; // 1. Teilauftrag "Parameter lesen" vorbereiten und abschicken
	  
	  // vom 1. Teilauftrag "Parameter lesen" die Antwort abwarten und dann auswerten
	  IF #sbRdStart1 THEN
	    
	    // Ablöschen des Empfangspuffers
	    #sxRespParaMulti.sxHeader.syReqRef := B#16#00;
	    #sxRespParaMulti.sxHeader.syReqId := B#16#00;
	    #sxRespParaMulti.sxHeader.syAxisNo := B#16#00;
	    #sxRespParaMulti.sxHeader.syParaNo := B#16#00;
	    
	    FOR #piCount := 1 TO #siLenParaMulti DO
	      #sxRespParaMulti.sxData[#piCount] := B#16#00;
	    END_FOR;
	    
	    // LESEN AZYKLISCH
	    #piLenTele := #siLenHeader + #siLenParaMulti;
	    #RDREC_1(REQ := True,                                // Startimpuls
	             ID := #hardwareId,                         // Diagnoseadresse        
	             INDEX := 47,                                  // Rahmentyp           
	             MLEN := INT_TO_UINT(#piLenTele),             // maximale Länge
	             VALID => #pbValidSFB,                         // neuer Datensatz empfangen und gültig      
	             BUSY => #sbRdBusy,                           // Slave beschäftigt
	             ERROR => #sbRdError,                          // Fehler beim Schreiben
	             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code 
	             LEN => #piLenSFB,                           // Länge des gelesenen Datensatzes
	             RECORD := #sxRespParaMulti);                   // Zeiger auf gelesenen Datensatz
	    
	    // Ausgänge setzen
	    #sbBusy := #sbRdBusy;
	    #sbDone := #pbValidSFB;
	    
	    // Fehler auswerten
	    IF #sbRdError THEN
	      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
	      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
	      
	      // Fehlerstatus setzen
	      #siErrorId := 3;
	      #DiagId := #pwWord1;
	      
	      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
	      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
	        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
	        NOT (#pwWord1 = DW#16#80C4) THEN
	        
	        // Wiederholungsauftrag wieder zurücknehmen
	        #sbWrStart1 := False;
	        #sbRdStart1 := False;
	        #sbWrite := False;
	        
	        // Fehler ausgeben 
	        #sbError := #sbRdError;
	        
	      ELSE
	        // Fehlerwiederholauftrag ??                   
	        IF #siErrorCount = #siMaxErrCount THEN
	          
	          // Wiederholungsauftrag wieder zurücknehmen
	          #sbWrStart1 := False;
	          #sbRdStart1 := False;
	          #sbWrite := False;
	          
	          //Fehlerzähler zurücksetzen
	          #siErrorCount := 0;
	          
	          
	          // Fehler ausgeben 
	          #sbError := #sbRdError;
	          
	          // nix tun bis Zähler überläuft
	        ELSE
	          #siErrorCount := #siErrorCount + 1;
	        END_IF;
	      END_IF;
	      
	      // Fehler : die Auftragsreferenz der Antwort übertimmt nicht mit der Auftragsreferenz der Anfrage überein
	    ELSIF NOT (#siReqRef = BYTE_TO_INT(#sxRespParaMulti.sxHeader.syReqRef)) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart1 := False;
	      #sbRdStart1 := False;
	      #sbWrite := False;
	      
	      // Fehler : falsche Auftragskennung zurück erhalten    
	    ELSIF NOT (#sxRespParaMulti.sxHeader.syReqId = B#16#81 OR #sxRespParaMulti.sxHeader.syReqId = B#16#01) AND
	      NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart1 := False;
	      #sbRdStart1 := False;
	      #sbWrite := False;
	      
	      // Fehler : die angeforderte Anzahl Parameter entspricht nicht der übermittelten Anzahl Parameter überein
	    ELSIF NOT (#sxRespParaMulti.sxHeader.syParaNo = B#16#01) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart1 := False;
	      #sbRdStart1 := False;
	      #sbWrite := False;
	      
	      // Fehler : die Achse entspricht nicht der übergebenen Achse
	    ELSIF NOT (#syAxisNo = #sxRespParaMulti.sxHeader.syAxisNo) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart1 := False;
	      #sbRdStart1 := False;
	      #sbWrite := False;
	      
	      // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
	    ELSIF NOT #sbRdBusy AND #pbValidSFB THEN
	      
	      // die angefragten Parameter auswerten und im Puffer abspeichern
	      // ermitteltes Format des Parameters abspeichern
	      #syFormat := #sxRespParaMulti.sxData[1];
	      
	      // Format = Error ? = > gesendeter Parameter fehlerhaft
	      IF (BYTE_TO_INT(#sxRespParaMulti.sxData[1]) = 68) THEN
	        
	        // Format = Error, zwei Bytes zu übermittelten Fehlernummer zusammenfassen
	        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	            
	        #sbError := True;
	            
	        // ermittelte Fehlernummer im Puffer abspeichern
	        #ErrorNo := #pwWordHigh XOR #pwWordLow;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
	        #swParaError := #swParaError OR W#16#01;
	        
	        // Format = Byte ? = > gesendeter Parameter ein Byte lang
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#41) OR
	        (#sxRespParaMulti.sxData[1] = B#16#02) OR (#sxRespParaMulti.sxData[1] = B#16#05) THEN
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Format = Word ? = > gesendeter Parameter zwei Bytes lang
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#42) OR (#sxRespParaMulti.sxData[1] = B#16#03)
	        OR (#sxRespParaMulti.sxData[1] = B#16#06) OR (#sxRespParaMulti.sxData[1] = B#16#0A) THEN
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        
	        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang
	      ELSIF (#sxRespParaMulti.sxData[1] = B#16#43) OR (#sxRespParaMulti.sxData[1] = B#16#04) OR
	        (#sxRespParaMulti.sxData[1] = B#16#07) OR (#sxRespParaMulti.sxData[1] = B#16#08) OR
	        (#sxRespParaMulti.sxData[1] = B#16#0D) THEN
	        
	        // ermittelte Fehlernummer im Puffer zurücksetzen
	        #ErrorNo := W#16#00;
	        
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	        #swParaError := #swParaError AND W#16#FFFE;
	        
	        // Unbekanter Datentyp
	      ELSE
	        
	        #siErrorId := 5;
	        #sbError := True;
	        #sbDone := False;
	        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
	        #swParaError := #swParaError OR W#16#01;
	        
	      END_IF;
	      
	      // Fehlerkennung zurücknehmen
	      IF (#siErrorId = 3) OR (#siErrorId = 1) THEN
	        #siErrorId := 0;
	        #sbError := False;
	      END_IF;
	      
	      #DiagId := W#16#00;
	      
	      // 1. Teilauftrag "Parameter lesen" ist abgeschlossen
	      #sbRdStart1 := False;
	      
	      // einer der gesendeten Parameter ist fehlerhaft => Abbruch, kein "Parameter schreiben" erforderlich
	      IF (#swParaError = W#16#00) THEN
	        #sbWrStart2 := True;
	      ELSE
	        #sbWrStart2 := False;
	      END_IF;
	    END_IF; // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
	  END_IF; // vom 1. Teilauftrag "Parameter lesen" die Antwort abwarten und dann auswerten 
	  
	  // 2. Teilauftrag "Parameter schreiben bzw. ändern" vorbereiten und abschicken
	  IF #sbWrStart2 THEN
	    
	    // Ablöschen des Sendepuffers            
	    FOR #piCount := 1 TO #siLenChaPara DO
	      // Parameteradresse und Parameterwert des Parameters 
	      #sxChaParaMulti.sxData[#piCount] := B#16#00;
	    END_FOR;
	    
	    // Auftrags-HEADER erstellen
	    // Auftragsreferenz
	    #sxChaParaMulti.sxHeader.syReqRef := INT_TO_BYTE(#siReqRef);
	    
	    // Auftragskennung 0x01=Request Parameters | 0x02=Change Parameters
	    #sxChaParaMulti.sxHeader.syReqId := B#16#02;
	    
	    // Achse
	    #sxChaParaMulti.sxHeader.syAxisNo := #syAxisNo;
	    
	    // Anzahl Parameter        
	    #sxChaParaMulti.sxHeader.syParaNo := B#16#01;
	    
	    // Auftrags-PARAMETERADRESSE erstellen                
	    // Attribute of parameters (0x10=Value, 0x30=Text)
	    #sxChaParaMulti.sxData[1] := B#16#10;
	    
	    // No. of elements (DEC: for single elements=1) 
	    #sxChaParaMulti.sxData[2] := B#16#01;
	    
	    // Parameternummer des Parameters                                
	    #sxChaParaMulti.sxData[4] := UINT_TO_BYTE(#Parameter);
	    #sxChaParaMulti.sxData[3] := WORD_TO_BYTE(SHR(IN := UINT_TO_WORD(#Parameter), N := 8));
	    
	    // Subindex des Parameters
	    #sxChaParaMulti.sxData[6] := UINT_TO_BYTE(#Index);
	    #sxChaParaMulti.sxData[5] := WORD_TO_BYTE(SHR(IN := UINT_TO_WORD(#Index), N := 8));
	    
	    // Auftrags-PARAMETERVALUE erstellen    
	    // Format (BYTE, WORD, DWORD des Parameterwert übergeben
	    #sxChaParaMulti.sxData[7] := #syFormat;
	    
	    // Number of value
	    #sxChaParaMulti.sxData[8] := B#16#01;
	    
	    // Value of parameter in Bytes
	    IF (#syFormat = B#16#41) OR
	      (#syFormat = B#16#02) OR (#syFormat = B#16#05) THEN
	      
	      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1))));
	      #sxChaParaMulti.sxData[10] := 16#00;  //WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1)), N := 8)));
	      
	      // Value of parameter in Word
	    ELSIF (#syFormat = B#16#42) OR (#syFormat = B#16#03) OR
	      (#syFormat = B#16#06) OR (#syFormat = B#16#0A) THEN
	      
	      #sxChaParaMulti.sxData[10] := WORD_TO_BYTE(DWORD_TO_WORD(DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1))));
	      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1)), N := 8)));
	      
	      // Value of parameter in DWord    
	    ELSIF (#syFormat = B#16#43) OR (#syFormat = B#16#04) OR
	      (#syFormat = B#16#07) OR (#syFormat = B#16#0D) THEN
	      
	      #sxChaParaMulti.sxData[12] := WORD_TO_BYTE(DWORD_TO_WORD(DINT_TO_DWORD(#ValueWrite2)));
	      #sxChaParaMulti.sxData[11] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(#ValueWrite2), N := 8)));
	      #sxChaParaMulti.sxData[10] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(#ValueWrite2), N := 16)));
	      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(#ValueWrite2), N := 24)));
	      
	      
	      // Value of parameter in DWord (FloatingPoint)   
	    ELSIF (#syFormat = B#16#08) THEN
	      
	      #sxChaParaMulti.sxData[12] := WORD_TO_BYTE(DWORD_TO_WORD(REAL_TO_DWORD(#ValueWrite1)));
	      #sxChaParaMulti.sxData[11] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := REAL_TO_DWORD(#ValueWrite1), N := 8)));
	      #sxChaParaMulti.sxData[10] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := REAL_TO_DWORD(#ValueWrite1), N := 16)));
	      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := REAL_TO_DWORD(#ValueWrite1), N := 24)));
	      
	    END_IF;
	    
	    // SCHREIBEN AZYKLISCH
	    #piLenTele := #siLenHeader + #siLenChaPara;
	    #WRREC_1(REQ := True,                                // Startimpuls
	             ID := #hardwareId,                         // Diagnoseadresse
	             INDEX := 47,                                  // Rahmentyp
	             LEN := INT_TO_UINT(#piLenTele),             // maximale Länge
	             DONE => #sbWrDone,                           // Schreibauftrag beendet
	             BUSY => #sbWrBusy,                           // Slave beschäftigt
	             ERROR => #sbWrError,                          // Fehler beim Schreiben
	             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
	             RECORD := #sxChaParaMulti);                    // Zeiger auf zu schreibenen Datensatzes
	    
	    // Ausgänge setzen
	    #sbBusy := #sbWrBusy;
	    #sbDone := #sbWrDone;
	    
	    // Fehler auswerten
	    IF #sbWrError THEN
	      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
	      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
	      
	      // Fehlerstatus setzen
	      #siErrorId := 3;
	      #sbError := False;
	      #DiagId := #pwWord1;
	      
	      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
	      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
	        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
	        NOT (#pwWord1 = DW#16#80C4) THEN
	        
	        // Wiederholungsauftrag wieder zurücknehmen
	        #sbWrStart2 := False;
	        #sbRdStart2 := False;
	        #sbWrite := False;
	        
	        // Fehler ausgeben 
	        #sbError := #sbWrError;
	        
	      ELSE
	        // Fehlerwiederholauftrag ??                   
	        IF #siErrorCount = #siMaxErrCount THEN
	          
	          // Wiederholungsauftrag wieder zurücknehmen
	          #sbWrStart2 := False;
	          #sbRdStart2 := False;
	          #sbWrite := False;
	          
	          //Fehlerzähler zurücksetzen
	          #siErrorCount := 0;
	          
	          
	          // Fehler ausgeben 
	          #sbError := #sbWrError;
	          
	          // nix tun bis Zähler überläuft
	        ELSE
	          #siErrorCount := #siErrorCount + 1;
	        END_IF;
	      END_IF;
	      
	      // kein Fehler beim SCHEIBEN AZYKLISCH und Auftrag fertig 
	    ELSIF NOT #sbWrBusy AND #sbWrDone THEN
	      // Fehlerkennung zurücknehmen
	      #DiagId := W#16#00;
	      
	      // Schreibauftrag fertig melden und Leseantrag anstossen
	      #sbWrStart2 := False;
	      #sbRdStart2 := True;
	    END_IF;
	  END_IF; // 2. Teilauftrag "Parameter schreiben bzw. ändern" vorbereiten und abschicken
	  
	  // vom 2. Teilauftrag "Parameter schreiben bzw. ändern" die Antwort abwarten und dann auswerten
	  IF #sbRdStart2 THEN
	    
	    // Ablöschen des Empfangspuffers
	    #sxRespParaMulti.sxHeader.syReqRef := B#16#00;
	    #sxRespParaMulti.sxHeader.syReqId := B#16#00;
	    #sxRespParaMulti.sxHeader.syAxisNo := B#16#00;
	    #sxRespParaMulti.sxHeader.syParaNo := B#16#00;
	    
	    FOR #piCount := 1 TO #siLenParaMulti DO
	      #sxRespParaMulti.sxData[#piCount] := B#16#00;
	    END_FOR;
	    
	    // LESEN AZYKLISCH
	    #piLenTele := #siLenHeader + #siLenParaMulti;
	    #RDREC_1(REQ := True,                                // Startimpuls
	             ID := #hardwareId,                         // Diagnoseadresse        
	             INDEX := 47,                                  // Rahmentyp           
	             MLEN := INT_TO_UINT(#piLenTele),             // maximale Länge
	             VALID => #pbValidSFB,                         // neuer Datensatz empfangen und gültig   
	             BUSY => #sbRdBusy,                           // Slave beschäftigt
	             ERROR => #sbRdError,                          // Fehler beim Schreiben
	             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code 
	             LEN => #piLenSFB,                           // Länge des gelesenen Datensatzes
	             RECORD := #sxRespParaMulti);                   // Zeiger auf gelesenen Datensatz
	    
	    // Ausgänge setzen
	    #sbBusy := #sbRdBusy;
	    #sbDone := #pbValidSFB;
	    
	    // Fehler auswerten
	    IF #sbRdError THEN
	      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
	      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
	      
	      // Fehlerstatus setzen
	      #siErrorId := 3;
	      #DiagId := #pwWord1;
	      
	      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
	      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
	        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
	        NOT (#pwWord1 = DW#16#80C4) THEN
	        
	        // Wiederholungsauftrag wieder zurücknehmen
	        #sbWrStart2 := False;
	        #sbRdStart2 := False;
	        #sbWrite := False;
	        
	        // Fehler ausgeben 
	        #sbError := #sbRdError;
	        
	      ELSE
	        // Fehlerwiederholauftrag ??                   
	        IF #siErrorCount = #siMaxErrCount THEN
	          
	          // Wiederholungsauftrag wieder zurücknehmen
	          #sbWrStart2 := False;
	          #sbRdStart2 := False;
	          #sbWrite := False;
	          
	          //Fehlerzähler zurücksetzen
	          #siErrorCount := 0;
	          
	          
	          // Fehler ausgeben 
	          #sbError := #sbRdError;
	          
	          // nix tun bis Zähler überläuft
	        ELSE
	          #siErrorCount := #siErrorCount + 1;
	        END_IF;
	      END_IF;
	      
	      // Fehler : die Auftragsreferenz der Antwort übertimmt nicht mit der Auftragsreferenz der Anfrage überein
	    ELSIF NOT (#siReqRef = BYTE_TO_INT(#sxRespParaMulti.sxHeader.syReqRef)) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart2 := False;
	      #sbRdStart2 := False;
	      #sbWrite := False;
	      
	      // Fehler : falsche Auftragskennung zurück erhalten    
	    ELSIF NOT (#sxRespParaMulti.sxHeader.syReqId = B#16#82 OR #sxRespParaMulti.sxHeader.syReqId = B#16#02) AND
	      NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart2 := False;
	      #sbRdStart2 := False;
	      #sbWrite := False;
	      
	      // Fehler : die angeforderte Anzahl Parameter entspricht nicht der übermittelten Anzahl Parameter überein
	    ELSIF NOT (#sxRespParaMulti.sxHeader.syParaNo = B#16#01) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart2 := False;
	      #sbRdStart2 := False;
	      #sbWrite := False;
	      
	      // Fehler : die Achse entspricht nicht der übergebenen Achse
	    ELSIF NOT (#syAxisNo = #sxRespParaMulti.sxHeader.syAxisNo) AND NOT #sbRdBusy AND #pbValidSFB THEN
	      #siErrorId := 1;
	      #sbError := True;
	      #sbDone := False;
	      
	      // Wiederholungsauftrag wieder zurücknehmen
	      #sbWrStart2 := False;
	      #sbRdStart2 := False;
	      #sbWrite := False;
	      
	      // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
	    ELSIF NOT #sbRdBusy AND #pbValidSFB THEN
	      
	      // 2. Teilauftrag "Parameter schreiben bzw. ändern" negative Rückmeldung erhalten 
	      IF #sxRespParaMulti.sxHeader.syReqId = B#16#82 THEN
	        
	        // die angefragten Parameter auswerten und im Puffer abspeichern
	        // Format des Parameters auswerten, bei Format = Error Fehler auswerten 
	        IF (BYTE_TO_INT(#sxRespParaMulti.sxData[1]) = 68) THEN
	          
	          // Fehlerwert ermitteln und abspeichern 
	          // Format = Word, zwei Bytes zu übermitteltem Parameterwert zusammenfassen
	          #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
	          #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
	          #pwWord1 := #pwWordHigh XOR #pwWordLow;
	            
	          #sbError := True;
	            
	          // ermittelte Fehlernummer im Puffer zurücksetzen
	          #ErrorNo := W#16#00;
	          
	          #ErrorNo := #pwWord1;
	          
	          // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
	          #swParaError := #swParaError OR W#16#01;
	          
	        ELSE
	          
	          // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
	          #swParaError := #swParaError AND W#16#FFFE;
	          
	          // ermittelte Fehlernummer im Puffer zurücksetzen
	          #ErrorNo := W#16#00;
	        END_IF;
	      END_IF; // 2. Teilauftrag "Parameter schreiben bzw. ändern" negative Rückmeldung erhalten
	      
	      // Fehlerkennung zurücknehmen
	      IF (#siErrorId = 3) OR (#siErrorId = 1) THEN
	        #siErrorId := 0;
	        #sbError := False;
	      END_IF;
	      
	      #DiagId := W#16#00;
	      
	      // 2. Teilauftrag "Parameter schreiben bzw. ändern" ist abgeschlossen
	      #sbRdStart2 := False;
	      #sbWrite := False;
	      
	    END_IF; // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
	  END_IF; // vom 2. Teilauftrag "Parameter schreiben bzw. ändern" die Antwort abwarten und dann auswerten 
	END_IF; // Auftrag "Parameter schreiben" wurde ausgelöst
	
	#pdDWordHigh := SHL(IN := INT_TO_DWORD(#siErrorId), N := 16);
	#pdDWordLow := WORD_TO_DWORD(#swParaError);
	
	// ermittelter Parameterwert eintragen (Word)
	#ErrorId := #pdDWordHigh XOR #pdDWordLow;
	
	// Initialisierung von Ausgängen
	#Busy := #sbBusy;
	#Error := #sbError;
	#Format := #syFormat;
	// Änderung wegen verhalten von Ready  
	#Done := #sbDone;
	// Prüfen, ob Auftrag abgeschlossen ist
	IF ((#Error OR #Done) AND NOT #sbReady) THEN
	  #Ready := True;
	  #sbReady := True;
	ELSE
	  #Ready := False;
	END_IF;
	
	
END_FUNCTION_BLOCK

